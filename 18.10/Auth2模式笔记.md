# Auth2模式笔记

## 什么是oauth2

oauth（开放授权）是一个开放标准，允许哦用户授权第三方移动应用访问他们存储在另外的服务提供者的信息，而不需要将用户名和密码提供给第三方移动应用或分享他们数据的所有内容。但是不兼容oauth1.0，1.0全部废弃了。

## 为什么需要oauth2

在没有oauth2之前，我们能想到两个不同应用互相访问的方式就是1. 提供密码。2. 提供密码的方式觉得很不安全，所以就想着先到对方服务器进行验证后在进行调用，其中就涉及了令牌的问题，以及令牌失效和吊销的问题。

基于这些问题，所以出现了一个标准，整合了大部分授权相关的流程点和基本问题，能够快速按照标准实现，市面上也有了很多标注实现：shiro，security是比较常用，实现起来简单的框架。

## 基于令牌的模式

第三方应用通过安全的验证方式，从服务提供者中获取想对应的令牌，在通过令牌去访问真正的资源。

类似大企业进入内部的时候会通过身份证换取一个访客卡，然后你通过访客卡就能够进入公司，但是访客卡也是有限制的某些地方是你进不去的。相类似。

## 令牌的分类

access_token：真正进行资源服务器访问的凭证，所有的目的都是为了这个

refresh_token: 不具备持久化的客户端，是不支持将refresh进行存储的

客户端id：客户端id是生成后注册到授权服务器的

客户端凭证：客户端凭证是在授权服务器签发后发送的身份证验证

## 参与对象名词解释

1. 第三方应用程序，成为客户端（第三方桌面网站，移动网站，app，第三方应用服务器）都能够成为，其中还区分是否有持久化能力：前三个都不具备持久化能力，第三方应用服务器具备持久化能力）
2. http服务提供商：就是目标服务提供商
3. 资源所有者：就是资源对应归属的用户
4. 用户代理，一般指的都是浏览器
5. 认证服务器：服务提供商专门用来处理认证的服务器
6. 资源服务器：服务提供商存放用户生成的资源的服务器，和认证服务器可以试一台也可以不是一台。

## oauth的四种模式

1. 授权码模式：code+clientId+secret 来验证获取accesstoken以及refreshtoken
2. 简易模式：直接进行重定向，授权来获取accesstoken
3. 密码模式：客户端保证安全的情况下（同一家企业的app），通过用户密码进行授权验证，使用默认的授权
4. 客户端模式：客户端保证安全的情况下（同一家模块的功能）用户密码都不用了，通过secret来验证授权

### 授权码模式（第三方服务器）

1. 资源所有者，通过浏览器，访问第三方应用服务器，第三方应用服务器重定向到服务提供商的授权认证服务器
2. 带着地址信息，重定向到授权页面，服务提供商提供的，进行用户密码认证验证
3. 用户输入用户名密码授权认证服务器，服务器通过地址信息进行回调，并且返回对应的code
4. 用户代理浏览器将授权码，传递给第三方应用服务器，通过授权码去认证服务器获取链接token、刷新token存储在服务器上
5. 通过前端和后端就能够获取对应的资源数据

### 简易模式（直接返回access_token）

1. 资源所有者通过用户代理访问第三方应用服务
2. 第三方应用将页面重定向到服务提供商的授权页面
3. 用户进行授权
4. 重定向到页面，带上access_token
5. 第三方应用访问资源服务器

缺点：该模式下的access_token容易泄露，并且不可以刷新（所以不推荐使用）不得已的情况下才使用

### 密码模式（同一个企业的产品，因为内部都互相知道密码，所以可以直接使用密码）

2. 用户访问同一个企业的产品
2. 用账号和密码换取token
3. 访问资源服务器（自己的服务器的时候才可以这么做）

### 客户端模式（同一个企业的产品，就是内部调用，不需要知道用户名密码，直接调用）

1. 鉴权服务器直接对客户端进行身份验证，换取token
2. Token获取完毕后直接访问资源

## 如何实现

### 服务端表结构设计

用户表：id、用户名、密码、名称

客户端表：id、客户端名称，客户端id，客户端安全key

在官方网站有提供不同语言的标准实现推荐：

https://oauth.net/2/

https://oauth.net/code/java/

1. 自己实不太现实，非必须，肯定使用现成的。
   1. 授权认证服务端的方法
      1. access_token的返回
      2. access_token的验证
   2. 资源服务端的方法：通过拦截器去验证token
   3. 客户端的方法：通过获取token去进行注册和验证返回对应的token、以及刷新token
2. 使用现成的框架实现，也就是选型，通过官方网站的查找，有提供一些线程的客户端和服务端的库，可以参考使用。https://oauth.net/code/java/
3. 但实际上未来的微服务选型，应该支持不同语言的调用，使用http的方式，或者统一的方式，让客户端和服务端使用不同语言编写和调用。
4. 由于我们常用的权限框架为apache shiro、security所以选型的时候尽量这两个都有一种实现

### shiro实现思路

https://yq.aliyun.com/articles/414182

https://www.iteye.com/blog/jinnianshilongnian-2038646

https://blog.csdn.net/qq_34021712/article/details/80510774

### security实现

通过spring-cloud-oauth2能够通过配置，加上编写对应实现类，快熟实现一个oauth2的系统弄个调用哦。

1. 引用oauth2的模块，其中包含了客户端和服务端
2. 对客户端和认证服务器，通过security进行整合，spring默认提供了很多开口，配置之后就可以直接使用，参考myshop的功能实现
3. 通过内存存储令牌
4. 通过jdbc存储令牌
5. 通过redis存储令牌
6. 使用jwt存储令牌是不被推荐的方式
7. 基于此次的功能，可以继续添加rbac自定义认证的功能。

### security原理

基于Servlet过滤器，进行拦截、Ioc和Aop，为web请求和方法调用提供身份确认和授权处理，避免了代码耦合，减少了大量重复的代码工作

1. 配置通过配置WebSecurityConfigurerAdapter重写configure方法，配置认证登录的url、提交表单的url，配置相关的url，配置对应的设定
2. UserDetailSevice实现loadUserByUsername返回一个UserDetail，其他通过异常处理来实现
3. 过滤器链条
   1. UsernamePasswordAuthenticationFilter
   2. BaseAuthenticationFilter
   3. 等等自定义过滤器
   4. ExceptionTranslationFilter
   5. FilterSecurity Interceptor
   6. restApi
4. 认证结果如何在多线程中共享
   1. SecurityContextPersistenceFilter所有请求先进来的时候，都会在个过滤器中检查是否有认证的authentication对象，有的话就放入一个securityContext里面，然后交给SecurityContextHolder处理
   2. 通过threadlocal机械能线程中共对应的securityContext的authcatione的线程变量共享
   3. 使用注解实现

## 演示demo的实现

shiro版本

security版本



## 相关的安全防范注意事项



## 参考资料

[OAuth2介绍与使用](https://baijiahao.baidu.com/s?id=1620083471706505859&wfr=spider&for=pc)

[]()